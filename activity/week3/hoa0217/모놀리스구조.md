
스크립트에 load-test로 진행했습니다.
```js
import http from 'k6/http';
import {sleep} from 'k6';

export const options = {
  // Key configurations for avg load test in this section
  stages: [{duration: '1m', target: 100}, // traffic ramp-up from 1 to 50 users over 1 minutes.
    {duration: '5m', target: 100}, // stay at 100 users for 5 minutes
    {duration: '1m', target: 0}, // ramp-down to 0 users
  ],
};

export default () => {
  const urlRes = http.get('http://localhost:8080/api/v1/order/1');
  sleep(1);
  // MORE STEPS
  // Here you can have more steps or complex script
  // Step1
  // Step2
  // etc.
};
```

실행 명령어
```shell
k6 run --out influxdb=http://localhost:8086/k6 load-test.js
```

## 단순 조회
단순 조회는 순차적으로 order, product, delivery, refund를 조회합니다.
order product까지 포함하면 총 5개의 테이블을 순차적으로 조회하게 됩니다.

아래와 같은 쿼리가 연속적으로 나갑니다.

```sql
Hibernate: 
    select
        order0_.id as id1_2_0_,
        order0_.created_at as created_2_2_0_,
        order0_.updated_at as updated_3_2_0_,
        order0_.order_number as order_nu4_2_0_,
        order0_.order_status as order_st5_2_0_ 
    from
        orders order0_ 
    where
        order0_.id=?
Hibernate: 
    select
        orderprodu0_.id as id1_1_,
        orderprodu0_.created_at as created_2_1_,
        orderprodu0_.updated_at as updated_3_1_,
        orderprodu0_.order_id as order_id4_1_,
        orderprodu0_.product_id as product_5_1_ 
    from
        order_products orderprodu0_ 
    where
        orderprodu0_.order_id=?
Hibernate: 
    select
        product0_.id as id1_4_0_,
        product0_.created_at as created_2_4_0_,
        product0_.updated_at as updated_3_4_0_,
        product0_.bundle_name as bundle_n4_4_0_,
        product0_.bundle_quantity as bundle_q5_4_0_,
        product0_.description as descript6_4_0_,
        product0_.price as price7_4_0_,
        product0_.product_name as product_8_4_0_ 
    from
        products product0_ 
    where
        product0_.id=?
Hibernate: 
    select
        product0_.id as id1_4_0_,
        product0_.created_at as created_2_4_0_,
        product0_.updated_at as updated_3_4_0_,
        product0_.bundle_name as bundle_n4_4_0_,
        product0_.bundle_quantity as bundle_q5_4_0_,
        product0_.description as descript6_4_0_,
        product0_.price as price7_4_0_,
        product0_.product_name as product_8_4_0_ 
    from
        products product0_ 
    where
        product0_.id=?
Hibernate: 
    select
        delivery0_.id as id1_0_,
        delivery0_.created_at as created_2_0_,
        delivery0_.updated_at as updated_3_0_,
        delivery0_.address as address4_0_,
        delivery0_.delivery_momo as delivery5_0_,
        delivery0_.mobile as mobile6_0_,
        delivery0_.order_id as order_id7_0_,
        delivery0_.recipient_name as recipien8_0_,
        delivery0_.store_password as store_pa9_0_,
        delivery0_.zip_code as zip_cod10_0_ 
    from
        deliverys delivery0_ 
    where
        delivery0_.order_id=?
Hibernate: 
    select
        refund0_.id as id1_5_,
        refund0_.created_at as created_2_5_,
        refund0_.updated_at as updated_3_5_,
        refund0_.order_id as order_id4_5_,
        refund0_.refund_amount as refund_a5_5_,
        refund0_.refund_method_name as refund_m6_5_,
        refund0_.refund_status as refund_s7_5_ 
    from
        refunds refund0_ 
    where
        refund0_.order_id=?
```

성능테스트 결과는 아래와 같습니다.
<img width="900" src="https://github.com/user-attachments/assets/8e00df34-ce69-43f7-8d1f-af869d8bcf4f">

![image](https://github.com/user-attachments/assets/ad2be4f9-226a-43ec-8eb5-53d35d14f576)


## CompletableFuture를 활용한 병렬 처리

위에서는 테이블을 순차적으로 조회했다면 여기서는 동시에 여러스레드가 테이블에 접근하여 조회해옵니다.

CompletableFuture를 사용하면 실행순서는 보장할 수 없지만 조금 더 빠른 성능을 보일거라 예상했습니다.

```shell
Hibernate: 
    select
        order0_.id as id1_2_0_,
        order0_.created_at as created_2_2_0_,
        order0_.updated_at as updated_3_2_0_,
        order0_.order_number as order_nu4_2_0_,
        order0_.order_status as order_st5_2_0_ 
    from
        orders order0_ 
    where
        order0_.id=?
Hibernate: 
    select
        orderprodu0_.id as id1_1_,
        orderprodu0_.created_at as created_2_1_,
        orderprodu0_.updated_at as updated_3_1_,
        orderprodu0_.order_id as order_id4_1_,
        orderprodu0_.product_id as product_5_1_ 
    from
        order_products orderprodu0_ 
    where
        orderprodu0_.order_id=?
Hibernate: 
    select
        refund0_.id as id1_5_,
        refund0_.created_at as created_2_5_,
        refund0_.updated_at as updated_3_5_,
        refund0_.order_id as order_id4_5_,
        refund0_.refund_amount as refund_a5_5_,
        refund0_.refund_method_name as refund_m6_5_,
        refund0_.refund_status as refund_s7_5_ 
    from
        refunds refund0_ 
    where
        refund0_.order_id=?
Hibernate: 
    select
        delivery0_.id as id1_0_,
        delivery0_.created_at as created_2_0_,
        delivery0_.updated_at as updated_3_0_,
        delivery0_.address as address4_0_,
        delivery0_.delivery_momo as delivery5_0_,
        delivery0_.mobile as mobile6_0_,
        delivery0_.order_id as order_id7_0_,
        delivery0_.recipient_name as recipien8_0_,
        delivery0_.store_password as store_pa9_0_,
        delivery0_.zip_code as zip_cod10_0_ 
    from
        deliverys delivery0_ 
    where
        delivery0_.order_id=?
Hibernate: 
    select
        product0_.id as id1_4_0_,
        product0_.created_at as created_2_4_0_,
        product0_.updated_at as updated_3_4_0_,
        product0_.bundle_name as bundle_n4_4_0_,
        product0_.bundle_quantity as bundle_q5_4_0_,
        product0_.description as descript6_4_0_,
        product0_.price as price7_4_0_,
        product0_.product_name as product_8_4_0_ 
    from
        products product0_ 
    where
        product0_.id=?
Hibernate: 
    select
        product0_.id as id1_4_0_,
        product0_.created_at as created_2_4_0_,
        product0_.updated_at as updated_3_4_0_,
        product0_.bundle_name as bundle_n4_4_0_,
        product0_.bundle_quantity as bundle_q5_4_0_,
        product0_.description as descript6_4_0_,
        product0_.price as price7_4_0_,
        product0_.product_name as product_8_4_0_ 
    from
        products product0_ 
    where
        product0_.id=?
```

하지만 결과는 단순 조회랑 크게 차이가 없었습니다.. 오히려 조금 더 느려졌습니다.

<img width="900" src="https://github.com/user-attachments/assets/519a4b3e-8b43-4608-affb-c4add31a8a17">

![image](https://github.com/user-attachments/assets/210169c8-f455-49de-9852-84ee46eb1125)

이제 인덱스를 적용해보겠습니다.

## 단순 조회 + orderId Index
<img width="900" src="https://github.com/user-attachments/assets/9727d8b5-ce8d-4ce9-ae98-eac1fac3809c">

![image](https://github.com/user-attachments/assets/3c40069c-384f-4484-b695-64b992ef7542)

## CompletableFuture를 활용한 병렬 처리 + orderId Index
<img width="900" alt="스크린샷 2024-11-21 오전 12 52 41" src="https://github.com/user-attachments/assets/e5a42a93-fb24-43e5-9d77-fa4f41d6e95a">

![image](https://github.com/user-attachments/assets/f5a88192-18b7-430c-a1f0-34f99113827c)

## 로컬 캐싱

<img width="900" alt="image" src="https://github.com/user-attachments/assets/6f9b5a4a-cf65-4f08-b7e6-4f72f713ff28">

![image](https://github.com/user-attachments/assets/3aae04e7-2037-431a-931b-d369d68e48b9)